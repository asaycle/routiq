package main

import (
	"bytes"
	"fmt"
	"go/format"
	"path/filepath"
	"strings"

	annotationspb "google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func main() {
	var flags flagSet
	opts := protogen.Options{ParamFunc: flags.Set}

	opts.Run(func(p *protogen.Plugin) error {
		// .proto のディレクトリ（= Go パッケージ）ごとにランタイムを一度だけ生成
		emittedRuntime := map[string]bool{}

		for _, f := range p.Files {
			if !f.Generate {
				continue
			}

			srcPath := string(f.Desc.Path())   // 例: "api/proto/v1/tag.proto"
			pkgDir := filepath.Dir(srcPath)    // 例: "api/proto/v1"
			pkgName := string(f.GoPackageName) // 例: "routiq"

			// 1) ランタイム（zz_...）をパッケージに1回だけ出力
			if !emittedRuntime[pkgDir] {
				rtName := filepath.Join(pkgDir, "zz_resourcename_runtime.go")
				g := p.NewGeneratedFile(rtName, "") // importPath で掘られないよう空

				// ランタイム本文をテンプレから生成
				var body bytes.Buffer
				if err := runtimeBodyTmpl.Execute(&body, struct{}{}); err != nil {
					return err
				}

				// ヘッダ + 本文を連結して gofmt
				full := withHeader(pkgName, body.Bytes())
				formatted, ferr := format.Source(full)
				if ferr != nil {
					return fmt.Errorf("unparsable Go source (runtime): %w\n---\n%s\n---", ferr, full)
				}
				if _, werr := g.Write(formatted); werr != nil {
					return werr
				}
				emittedRuntime[pkgDir] = true
			}

			// 2) この .proto 専用のリソース生成（※ field の resource_reference は完全に無視する）
			out, err := generateForFile(p, f)
			if err != nil {
				return err
			}
			if out == nil {
				continue
			}

			base := strings.TrimSuffix(filepath.Base(srcPath), ".proto") + "_resource.go"
			filename := filepath.Join(pkgDir, base)
			g := p.NewGeneratedFile(filename, "") // importPath は空

			full := withHeader(pkgName, out.Bytes())
			formatted, ferr := format.Source(full)
			if ferr != nil {
				return fmt.Errorf("unparsable Go source: %w\n---\n%s\n---", ferr, full)
			}
			if _, werr := g.Write(formatted); werr != nil {
				return werr
			}
		}
		return nil
	})
}

// ヘッダ（Code generated + package 行）を確実に先頭に付ける
func withHeader(pkg string, body []byte) []byte {
	var b bytes.Buffer
	fmt.Fprintln(&b, "// Code generated by protoc-gen-go-resourcename; DO NOT EDIT.")
	fmt.Fprintln(&b, "package", pkg)
	fmt.Fprintln(&b)
	b.Write(body)
	return b.Bytes()
}

// オプション受け皿（必要に応じて拡張）
type flagSet struct{}

func (f *flagSet) Set(name, value string) error { return nil }

// ----- モデル -----

type variant struct {
	Const string   // e.g. "UserName_Users"
	Segs  []string // ["users","{user}"]
}

type accessor struct {
	Method string // "UserId"（現状は Get<Field> を出すので未使用）
	Field  string // "user"
}

type msgTarget struct {
	TypeName    string // "User"
	FieldName   string // "Name" (Go名: x.GetName() を呼ぶ想定)
	VariantType string // "UserNameVariant"
	NameType    string // "UserName"
	Variants    []variant
	FormatFuncs []formatFunc
	Accessors   []accessor
}

type formatFunc struct {
	Func string   // "FormatUserName", "FormatSpotNameUnderRoute"
	Segs []string // 出力セグメント
}

type fileData struct {
	Package string
	Targets []msgTarget
}

// ----- リソース抽出 -----

func generateForFile(_ *protogen.Plugin, f *protogen.File) (*bytes.Buffer, error) {
	var targets []msgTarget
	for _, m := range f.Messages {
		if t, ok := extractResource(m); ok {
			targets = append(targets, t)
		}
	}
	if len(targets) == 0 {
		return nil, nil
	}

	data := fileData{
		Package: string(f.GoPackageName),
		Targets: targets,
	}
	var buf bytes.Buffer
	if err := fileBodyTmpl.Execute(&buf, data); err != nil {
		return nil, err
	}
	return &buf, nil
}

func extractResource(m *protogen.Message) (msgTarget, bool) {
	// Message に google.api.resource が付いているか
	opts := m.Desc.Options().ProtoReflect()
	ext := protoGetResource(opts)
	if ext == nil || (len(ext.Pattern) == 0 && ext.Singular == "") {
		return msgTarget{}, false
	}

	// AIP-122: pattern を使用（Singular は旧仕様互換）
	patterns := ext.Pattern
	if len(patterns) == 0 && ext.Singular != "" {
		patterns = []string{ext.Singular}
	}

	var vlist []variant
	var fmts []formatFunc
	seen := map[string]bool{}

	for _, pat := range patterns {
		segs := strings.Split(pat, "/")
		vlist = append(vlist, variant{
			Const: fmt.Sprintf("%sName_%s", m.GoIdent.GoName, normalizeVariantConst(pat)),
			Segs:  segs,
		})

		ff := formatFunc{
			Func: fmt.Sprintf("Format%sName%s", m.GoIdent.GoName, normalizeVariantSuffix(pat)),
			Segs: segs,
		}
		// パターンが1個だけなら Suffix なしの "FormatXxxName" も出す
		if len(patterns) == 1 {
			ff.Func = fmt.Sprintf("Format%sName", m.GoIdent.GoName)
		}
		if !seen[ff.Func] {
			fmts = append(fmts, ff)
			seen[ff.Func] = true
		}
	}

	// name フィールドの Go 名（通常 "Name"）
	nameField := "Name"
	for _, field := range m.Fields {
		if field.Desc.Name() == "name" {
			nameField = field.GoName
			break
		}
	}

	// アクセサ（{var} ごとに ID アクセサ）
	idSet := map[string]bool{}
	var acc []accessor
	for _, pat := range patterns {
		for _, seg := range strings.Split(pat, "/") {
			if strings.HasPrefix(seg, "{") && strings.HasSuffix(seg, "}") {
				key := seg[1 : len(seg)-1]
				if !idSet[key] {
					acc = append(acc, accessor{Method: methodFromVar(key), Field: key})
					idSet[key] = true
				}
			}
		}
	}

	return msgTarget{
		TypeName:    m.GoIdent.GoName,
		FieldName:   nameField,
		VariantType: fmt.Sprintf("%sNameVariant", m.GoIdent.GoName),
		NameType:    fmt.Sprintf("%sName", m.GoIdent.GoName),
		Variants:    vlist,
		FormatFuncs: fmts,
		Accessors:   acc,
	}, true
}

func methodFromVar(v string) string {
	// user -> UserId, route -> RouteId
	return upperFirst(v) + "Id"
}

func normalizeVariantConst(p string) string {
	// "routes/{route}/spots/{spot}" -> "Routes_Spots"
	var out []string
	for _, s := range strings.Split(p, "/") {
		if strings.HasPrefix(s, "{") {
			continue
		}
		out = append(out, upperFirst(s))
	}
	if len(out) == 0 {
		return "Default"
	}
	return strings.Join(out, "_")
}

func normalizeVariantSuffix(p string) string {
	// "routes/{route}/spots/{spot}" -> "UnderRoutesSpots"
	var out []string
	for _, s := range strings.Split(p, "/") {
		if strings.HasPrefix(s, "{") {
			continue
		}
		out = append(out, upperFirst(s))
	}
	if len(out) == 0 {
		return "Default"
	}
	return "Under" + strings.Join(out, "")
}

func upperFirst(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// google.api.resource を取得（※ field の resource_reference は一切扱わない）
func protoGetResource(msg protoreflect.Message) *annotationspb.ResourceDescriptor {
	if !msg.IsValid() {
		return nil
	}
	ext := annotationspb.E_Resource
	if !msg.Has(ext.TypeDescriptor()) {
		return nil
	}
	v := msg.Get(ext.TypeDescriptor())
	if v.Message() == nil {
		return nil
	}
	rd, _ := v.Message().Interface().(*annotationspb.ResourceDescriptor)
	return rd
}
